# Naming

The naming rules were designed for use with C#. Where possible, they should be applied to elements of other languages (CSS, JavaScript, etc.) as well. 

## Basic Composition

### Valid Characters

* Identifiers should contain only alphabetic characters.
* The underscore is allowed only as a leading character for fields (or when included in a member generated by the IDE).
* Numbers are allowed only for local variables and method parameters and may then only appear as a suffix. Avoid using numbers wherever possible. (A valid use of a number in an identifier is in a sorting routine that accepts two elements; in that case, “value1” and “value2” are appropriate.)

### General Rules

* Names are in US-English (e.g. use “color” instead of “colour”).
* Names conform to English grammatical conventions (e.g. use `ImportableDatabase` instead of `DatabaseImportable`).
* Names should be as short as possible without losing meaning.
* Prefer whole words or stick to predefined short forms or abbreviations of words (as seen in section 5.4.1 – Local Variables and Parameters).
* Make sure to capitalize compound words correctly; if the word is not hyphenated, then it does not need a capital letter in the camel- or Pascal-cased form. For example, “metadata” is written as `Metadata` in Pascal-case, not `MetaData`.
* Acronyms should be Pascal-case as well (e.g. “Xml” or “Sql”) unless they are only two letters long. Acronyms at the beginning of a camel-case identifier are always all lowercase.
* Identifiers differing only by case may be defined within the same scope only if they identify different language elements (e.g. a local variable and a property).

      ```c#
      public void UpdateLength(int newLength, bool refreshViews)
      {
        int length = Length;
        // ...
      }      
      ```

* You may not use identifiers that are keywords in C#; neither may you use the @-symbol to turn a keyword into a valid identifier.

### Collision and Matching

* Do not name an element with the same identifier as its containing element (e.g. don’t create a static class named Expressions within a namespace called `Expressions`).
* Since C# allows it, you should use the same identifier for a property as its type if that is the most appropriate name in that context (this is often the case with `enum` properties).

## Capitalization

The following table lists the capitalization and naming rules for different language elements. Pascal-case capitalizes every individual word within an identifier, including the first one. Camel-case capitalizes all but the first word in an identifier.

Language Element | Case
--- | --- |
Class | Pascal
Interface | Pascal w/leading “I”
Struct | Pascal
Enumerated type | Pascal
Enumerated element | Pascal
Properties | Pascal
Generic parameters | Pascal
Public or protected readonly or const field | Pascal
Private field | Camel with leading underscore [\[1\]](#footnote_1)
Method argument | Camel
Local variable | Camel
Attributes | Pascal with “Attribute” suffix
Exceptions | Pascal with “Exception” suffix
Event handlers | Pascal with “EventHandler” suffix

## The Art of Choosing a Name

### General

* Readability is paramount, so while short names are desirable, make sure the identifier is clear and reads well (e.g. the property `bool UpdatesAutomatically` is better than `bool AutoUpdate`).
* Do not use a prefix for members in order to “group” them; this applies to enumerated type members as well.
* Do not use a generalized prefixing notation (e.g. Hungarian).
* Use the plural form to indicate lists instead of a suffix like “List” (e.g. use `appointments` instead of `appointmentList`).
* Avoid abbreviations unless that abbreviation is very standardized and accepted; this rule applies to abbreviations like using “max” instead of “maximum” or “num” instead of “count”, but does not apply to acronyms like “XML” or “SQL”.
 
### Namespaces
* Do not use a “library” prefix for types (e.g. instead of `QnoDatabase`, use a more descriptive name, like `MetaDatabase` or `RelationalDatabase`).
* Avoid very generic type names (e.g. `Element`, `Node`, `Message` or `Log`), which collide with types from the framework or other commonly-used libraries. Use a more specific name, if at all possible. [\[2\]](#footnote_2)
* If there are multiple types encapsulating similar concepts (but with different implementations, for example), you should use a common suffix to group them. For example, all the expression node types in the Encodo expressions library end in the word Expression.

### Interfaces

* Prefix interfaces with the letter “I”.

### Classes

* If a class implements a single interface, it should reflect this by incorporating the interface name into its own (e.g. `MetaList` implements `IList`).
* Static classes used as toolkits of static functions [\[3\]](#footnote_3) should use the suffix “Tools” and should go in a file ending in “Tools.cs”.

### Properties
* Properties should be nouns or adjectives.
* Prepend “Is” to the name for Boolean properties only if the intent is unclear without it. The next example shows such a case:

      ```c#
      public bool Empty { get; }
      public bool IsEmpty { get; }
      ```

  Even though it’s a property not a method, the first example might still be interpreted as a verb rather than an adjective. The second example adds the verb “Is” to avoid confusion, but both formulations are acceptable.
* A property’s backing field (if present) must be an underscore followed by the name of the property in camel case.
* Use common names, like `Item` or `Value`, for accessing the central property of a type.
* Do not include type information in property names. For example, for a property of type `IMetaRelation`, use the name Relation instead of the name `MetaRelation`.
* Make the identifier as short as possible without losing information. For example, if a class named `IViewContext` has a property of type `IViewContextHandler`, that property should be called `Handler`.
* If there are two properties that could be shortened in this way, then neither of them should be. If the class in the example above has another property of type `IEventListHandler`, then the properties should be named something like `ViewContextHandler` and `EventListhandler`, respectively.
* Avoid repeating information in a class member that is already in the class name. Suppose, there is an interface named `IMessages`; instances of this interface are typically named messages. That interface should not have a property named `Messages` because that would result in calls to `messages.Messages.Count`, which is redundant and not very readable. Instead, name the property something more semantically relevant, like `All`, so the call would read `messages.All.Count`.

### Methods

* Methods names should include a verb.
* Method names should not repeat information from the enclosing type. For example, an interface named `IMessages` should not have a method named `LogMessage`; instead name the method `Log`.
* State what a method does; do not describe the parameters (let code-completion and the signature do that for you).
* Methods that return values should indicate this in their name, like `GetList()`, `GetItem()` or `CreateDefaultDatabase()`. Though there is garbage collection in C#, you should still use `Get` to indicate retrieval of a local value and `Create` to indicate a factory method, which always creates a new reference. For example, instead of writing:

      ```c#
      public IDataList<GenericObject> GetList(IMetaClass cls)
      {
        return ViewApplication.Application.CreateContext<GenericObject>(cls);
      }
      ```
      
    You should write:

      ```c#
      public IDataList<GenericObject> CreateList(IMetaClass cls)
      {
        return ViewApplication.Application.CreateContext<GenericObject>(cls);
      }
      ```
* Avoid defining everything as a noun or a manager. Prefer names that are logically relevant, like `Missile.Launch()` rather than `MissileLauncher.Execute(missile)`.
* Methods that set a single property value should begin with the verb `Set`.
* The most generalized version of a method name should be reserved for the method that the framework wishes to encourage or that is used most often. An example from [6] is reproduced below:

    > Suppose you have two event-delivery mechanisms, one for immediate (synchronous) delivery and one for delayed (asynchronous) delivery. The names `sendEventNow()` and `sendEventLater()` suggest themselves. Now, if you want to encourage your users to use synchronous delivery (e.g., because it is more lightweight), you could name the synchronous method `sendEvent()` and keep `sendEventLater()` for the asynchronous case.

### Extension Methods

* Extension methods for a given class or interface should appear in a class named after the class or interface being extended, plus the suffix “Tools”. For example, extension methods for the class `Enum` should appear in a class named `EnumTools`.
* In the case of interfaces, the leading “I” should be dropped from the class name. For example, extension methods for the interface `IEnumerable<T>` should appear in a class named `EnumerableTools`.

### Parameters

* Prefer whole words instead of abbreviations (use `index` instead of `idx`).
* Parameter names should be based on their intended use or purpose rather than their type (unless the type indicates the purpose adequately).
* Do not simply repeat the type for the parameter name; use a name that is as short as possible, but doesn’t lose meaning. (E.g. a parameter of type `IDataContext` should be called `context` instead of `dataContext`.)
* However, if the method also, at some point, makes use of an `IViewContext`, you should make the parameter name more specific, using `dataContext` instead.
* For copy constructors or equality operators, name the object to be copied or compared `other`.

### Local Variables
Since local variables are limited to a much smaller scope and are not documented, the rules for name-selection are somewhat more relaxed.

* Try to use a name from section 5.4.1 – Local Variables and Parameters, if possible.
* Avoid using `temp` or `i` or `idx` for loop indexes. Use the suffix `Index` together with a descriptive prefix, as in `colIndex` or `itemIndex` or `memberIndex`.
* Names need only be as specific as the scope requires.
* The more limited the scope, the more abbreviated the variable may be.

### Return Values

* If a method creates a local variable expressly for the purpose of returning it as the result, that variable should be named `result`.

      ```c#
      object result = this[Fields.Id];

      if (result == null) { return null; }

      return (Int32)result;
      ```

### Events

* Single events should be named with a noun followed by a descriptive verb in the past tense.

      ```c#
      event EventHandler MessageDispatched;
      ```
* For paired events—one raised before executing some code and one raised after—use the gerund form (i.e. ending in “ing”) for the first event and the past tense (i.e. ending in “ed”) for the second event.

      ```c#
      event EventHandler MessageDispatching;
      event EventHandler MessageDispatched;
      ```
* Event receivers are like any other methods and should be named according to their task, not the event to which they are attached. The following method updates the user interface; it does this regardless of whether it is attached as an event receiver for the `MessageDispatched` event. 

      ```c#
      void UpdateUserInterface(object sender, EventArgs args)
      {
        // Implementation
      }
      ```
* Never start an event receiver method with “On” because Microsoft uses that convention for raising events.
* To trigger an event, use `Raise[EventName]`; this method must be `protected` and `virtual` to allow descendents to perform work before and after calling the base method.
* If you are raising events for changes made to properties, use the pattern `Raise[Property]Changed`.

### Enumerations

* Simple enumerations have singular names, whereas bit-sets  have plural names.

### Generic Parameters

* If a class or method has a single generic parameter, use the letter `T`.
* If there are two generic parameters and they correspond to a key and a value, then use `K` and `V`.
* Generic methods on classes with a generic parameter should use `TResult`, where appropriate. The example below shows a generic class with such a method.

      ```c#
      public class ListBookmarkSelection<T> : IBookmarkSelection
      {
        public IList<TResult> GetObjects<TResult>()
        {
          // Convert list contents from T to TResult
        }
      }
      ```
* Generic conversion functions should use `TInput` and `TOutput`, respectively.

      ```c#
      public static IList<TOutput> ConvertList<TInput, TOutput>(IList<TInput> input)
      {
        // Convert list contents from TInput to TOutput
      }
      ```
* If there are multiple parameters, but no pattern, name the “contained” element `T` (if there is one) and the other parameters something specific starting with the letter T.

### Delegates and Delegate Parameters

* Use a descriptive verb for delegate names, like the following examples:

      ```c#
      delegate string TransformString(T item);
      delegate bool ItemExists(T item);
      delegate int CompareItems(T first, T second);
      ```
* Delegate method parameter names should use the same grammar as the type, so that it sound natural when executed:

      ```c#
      public string[] ToStrings(TransformToString transform) 
      {
        // ...
        result[] = transform(item);
        // ...
      }
      ```
_This section applies to .NET 3.5 and newer._

* If a delegate is only used once or twice and has a relatively simple syntax, use `Func<>` for the parameter signature instead of declaring a delegate. The example above can be rewritten as:

      ```c#
      public string[] ToStrings(Func<T, string> transform) 
      {
        // ...
        result[] = transform(item);
        // ...
      }
      ```    
  This practice makes it much easier to determine the expected signature in code-completion as well.

### Lambda Expressions

* Do not use the highly non-expressive `x` as a parameter name.
* Parameters in a lambda expression should follow the same conventions as for parameters in standard methods.
* Do not make overly-complex lambda expressions; instead, define a method or use a delegate.

### Compiler Variables

* Compiler variables are all capital letters, with words separated by underscores.

      ```c#
      #if ENCODO_DEVELOPER
            return true;
      #else
            return false;
      #endif
      ```
      
## Common Names

### Local Variables and Parameters

The following table presents the method parameter or local variable name you should use for common types in the .NET and Encodo libraries. For other types, try to follow the spirit of the naming convention by choosing complete words or known abbreviations.

Type | Parameter & Variables | Variables only
--- | --- | ---
IMessageStore | messages | msgs
Exception | exception 
IMetaBase | metadata 
IMetaModel| model 
IMetaClass | cls, metaClass 
IMetaProperty | prop 
IMetaRelation | relation 
IMessageRecorder | recorder 
IMetaEndpoint | source, target 
IMetaElement | elt, element 
IDbCommand | cmd, command 
IDbConnection | conn, connection 
I*Database | db, database 
IQuery | query 
I*Context | context  
I*Handler | handler 
IMessage | msg, message 
IOperator | op, operation 
IExpression | expr, expression 
*Item | item 
String | name, message, msg, text (not n, txt) 
*Session | session 
*Application | application, app 
*EventArgs | args  
*List | list 
*Collection | collection, coll 
*Type | type 
*Column | column, col 
CultureInfo | culture 
Encoding | encoding 
*Bookmark | bookmark 
Appointment | appointment | appt

### User Interface Components

UI Elements should not include a suffix that indicates their control type unless there is another member that already uses that name or there are two controls that would use that name.[\[4\]](#footnote_4) If a suffix must be used, use one from the table below that best matches the control’s type.

UI Element | Suffix | Example
--- | --- | ---
Menu or toolstrip item | Item | _saveItem
Menu (context or main) | Menu | _logMenu
Listview, listbox, etc. | List | _fileList
Trees | Tree | _folderTree
Columns | Column | _lastNameColumn
Grids | Grid | _programsGrid
Groups | Group | _optionsGroup
Data Sources | Data | _programsData
Panels | Panel | _optionsPanel
Text boxes | Text | _lastNameText
Labels | Label | _lastNameLabel
Check boxes | Checkbox | _isEmployeeCheckbox
Page Control Tabs | Tab | _optionsTab
Radio Buttons | RadioButton | _salariedRadioButton
Page Controls | Pages | _preferencesPages
Dialogs | Dialog | _saveModelDialog
Image lists | Images | _smallMenuImages
Generic controls | Control | _someControl

### ASP Pages

* Do not add a suffix to the names of ASP pages since that name is used in the URL (at least in classic ASP.NET; naming patterns for MVC will come later).
* Do not add a prefix or suffix to pages used as AJAX-dialogs; instead, collect these pages into a sub-folder named “Dialogs”.

## Footnotes

<a name="footnote_1">[1]</a> This is not CLS-compliant because protected variables in Visual Basic always start with an underscore, so the code could not be re-generated in that language. We’ve chosen not to care.

<a name="footnote_2">[2]</a> Name collisions can be resolved using aliases or simply by using global:: namespace resolution, but this makes working with and reading the code both more difficult. For example, suppose we have made an interface for metadata properties in the `Encodo.Quino.Meta` namespace. The natural name for the interface is `IProperty`, but that’s too common a name, so we should use something like `IMetaProperty` instead. Other metadata interfaces would share this prefix, like `IMetaClass`, `IMetaRelation` and so on.

<a name="footnote_3">[3]</a> Such toolkits are also called “Convenience Methods” and often contain extension methods; see “7.17 – Using Extension Methods” for more information.

<a name="footnote_4">[4]</a> For example, this conflict can arise when you have a list control with a popup menu attached to it.